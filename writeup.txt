1.decisions

1.1实现page eviction策略
添加LRUcache，使用LRU策略来替换。LRU的实现是一个双向链表，新加入的节点、使用的放在最前面，内存满了就丢弃最后面的节点。

1.2B+tree插入删除节点
插入节点首先需要找到叶子节点。findLeafPage中，如果pid表示叶页面，则该方法从dirtypage中检索页面并返回。否则，该方法检索与pid相关联的内部页面并迭代其entry。
如果f为null，则该方法返回第一个entry的最左边的子项。否则，它将搜索具有大于或等于f的键的条目，并递归地调用该entry的左侧子项。如果不存在这样的entry，则该方法递归地调用最后一个条目的最右边的子项。

插入节点可能导致分裂。叶子节点：当页节点中元组数量等于n时，将其拆分成两个页节点。返回插入tuple所在的page，先计算需要移动到新页的元组数量，然后创建一个新的空页作为新页。接下来，它使用反向迭代器从当前
页中删除一半的元组，并将这些元组插入到新页中。随后，代码将中间的元组上推到父节点，以将两个叶节点连接在一起。最后，它更新各个节点的指针和父节点指针，并将所有修改的页面添加到dirty pages哈希表中以保持一致性。

内部节点：
计算需要移动到新页面的键值对的数量（即原节点的键值对总数除以2）。
创建一个新的内部节点，并将一半的键值对从原节点移动到新节点中。
从原节点中删除移动的键值对，并从其中移除与新节点相连的右子节点。
从原节点中删除移动的键值对，并将上一步中被移除的右子节点链接到新节点中。
更新新节点中所有子节点的父指针，以指向新节点。
在父节点中插入一个新键，其键值为被移动到新节点中的最大键值对的键值，其左子节点指向原节点，右子节点指向新节点。
更新原节点和新节点的父节点，以及父节点的子节点指针，然后将它们放入脏页集合中。
如果被移动到新节点中的最大键值对的键值大于或等于要插入的字段，则返回原节点；否则，返回新节点。

删除节点可能导致合并节点。

2.改变结构

加入LRUcache类；其他函数接口都没有改变。

3.基本完成

4.时间有的紧迫了，特别是lab3是5.7号，lab24.30号，可能有一点点赶。